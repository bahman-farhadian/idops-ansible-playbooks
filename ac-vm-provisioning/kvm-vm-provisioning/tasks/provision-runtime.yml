---
# =========================================================================
# STAGE: runtime (start + TCP port checks + optional snapshot)
# =========================================================================
- name: Explain runtime stage skip in check mode
  ansible.builtin.debug:
    msg: >-
      Runtime stage is skipped because mutation phases are disabled in check mode.
      Run make provision for actual start/port-check/snapshot actions.
  when: not (kvm_run_mutation_phases | bool)

- name: No runtime targets selected
  ansible.builtin.debug:
    msg: "No runtime targets were selected for this run."
  when: instance_runtime_targets | length == 0

- name: Check runtime target instance states
  ansible.builtin.command:
    cmd: virsh domstate "{{ item.instance_name }}"
  loop: "{{ instance_runtime_targets }}"
  loop_control:
    label: "{{ item.instance_name }}"
  register: runtime_target_state_results
  changed_when: false
  failed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - instance_runtime_targets | length > 0

- name: Fail when any runtime target instance does not exist
  ansible.builtin.fail:
    msg: >-
      Runtime stage cannot continue because these requested instances do not exist:
      {{
      runtime_target_state_results.results
      | rejectattr('rc', 'eq', 0)
      | map(attribute='item.instance_name')
      | join(', ')
      }}.
      Run stage=provision (or full run) first.
  when:
    - kvm_run_mutation_phases | bool
    - instance_runtime_targets | length > 0
    - >-
      (
        runtime_target_state_results.results
        | rejectattr('rc', 'eq', 0)
        | list
        | length
      ) > 0

- name: Build list of instances that need start
  ansible.builtin.set_fact:
    instances_to_start: >-
      {{
        instance_runtime_targets
        | zip(runtime_target_state_results.results)
        | rejectattr('1.stdout', 'equalto', 'running')
        | map(attribute='0')
        | list
      }}
  when:
    - kvm_run_mutation_phases | bool
    - instance_runtime_targets | length > 0

- name: Start instances that are not running
  ansible.builtin.command:
    cmd: virsh start "{{ item.instance_name }}"
  loop: "{{ instances_to_start | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  async: 90
  poll: 0
  register: start_jobs
  changed_when: true
  when:
    - kvm_run_mutation_phases | bool
    - (instances_to_start | default([])) | length > 0

- name: Wait for instance start operations
  ansible.builtin.async_status:
    jid: "{{ item.ansible_job_id }}"
  loop: "{{ start_jobs.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  register: start_job_status
  until: (start_job_status.finished | default(false)) | bool
  retries: 18
  delay: 5
  when:
    - kvm_run_mutation_phases | bool
    - item.ansible_job_id is defined

- name: Confirm TCP SSH port on runtime targets
  ansible.builtin.wait_for:
    host: "{{ item.instance_ipv4_address }}"
    port: "{{ item.ssh_port | int }}"
    delay: 0
    timeout: >-
      {{
        (
          kvm_debian12_network_boot_wait_timeout_seconds
          if (item.image_profile_id | default('')) == 'debian-12'
          else (kvm_wait_for_ssh_timeout_seconds | default(180))
        ) | int
      }}
    state: started
  loop: "{{ instance_runtime_targets }}"
  loop_control:
    label: "{{ item.instance_name }} ({{ item.instance_ipv4_address }}:{{ item.ssh_port | int }})"
  register: ssh_wait_results
  changed_when: false
  failed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - instance_runtime_targets | length > 0
    - kvm_wait_for_instance_ssh | default(true) | bool

- name: Build list of TCP SSH port timeout failures for runtime targets
  ansible.builtin.set_fact:
    runtime_ssh_timeout_instances: []
  when:
    - kvm_run_mutation_phases | bool
    - kvm_wait_for_instance_ssh | default(true) | bool

- name: Collect TCP SSH port timeout failures for runtime targets
  ansible.builtin.set_fact:
    runtime_ssh_timeout_instances: "{{ (runtime_ssh_timeout_instances + [item.item.instance_name]) | unique }}"
  loop: "{{ ssh_wait_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - >-
      (
        item.failed | default(false) | bool
      )
      or
      (
        (
          item.state is defined
        )
        and
        (
          (item.state | default('')) != 'started'
        )
      )
      or
      (
        item.msg is defined
        and
        (
          (item.msg | default('')) is search('Timeout when waiting')
        )
      )

- name: Collect domiflist diagnostics for TCP SSH port timeout instances
  ansible.builtin.command:
    cmd: virsh domiflist "{{ item }}"
  loop: "{{ runtime_ssh_timeout_instances | default([]) }}"
  loop_control:
    label: "{{ item }}"
  register: runtime_ssh_timeout_domiflist
  changed_when: false
  failed_when: false
  when:
    - (runtime_ssh_timeout_instances | default([])) | length > 0

- name: Build runtime timeout target model
  ansible.builtin.set_fact:
    runtime_ssh_timeout_targets: >-
      {{
        instance_runtime_targets
        | selectattr('instance_name', 'in', runtime_ssh_timeout_instances | default([]))
        | list
      }}
  when:
    - (runtime_ssh_timeout_instances | default([])) | length > 0

- name: Build Debian 12 timeout hint list
  ansible.builtin.set_fact:
    runtime_ssh_timeout_debian12_instances: >-
      {{
        runtime_ssh_timeout_targets
        | selectattr('image_profile_id', 'equalto', 'debian-12')
        | map(attribute='instance_name')
        | list
      }}
  when:
    - (runtime_ssh_timeout_instances | default([])) | length > 0

- name: Probe ICMP reachability for TCP SSH port timeout instances
  ansible.builtin.command:
    argv:
      - ping
      - -c
      - "1"
      - -W
      - "1"
      - "{{ item.instance_ipv4_address }}"
  loop: "{{ runtime_ssh_timeout_targets | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }} ({{ item.instance_ipv4_address }})"
  register: runtime_ssh_timeout_ping
  changed_when: false
  failed_when: false
  when:
    - (runtime_ssh_timeout_targets | default([])) | length > 0

- name: Collect domifaddr diagnostics from lease/arp/agent sources
  ansible.builtin.command:
    argv:
      - virsh
      - domifaddr
      - "{{ item.0.instance_name }}"
      - --source
      - "{{ item.1 }}"
  loop: >-
    {{
      (runtime_ssh_timeout_targets | default([]))
      | product(['lease', 'arp', 'agent'])
      | list
    }}
  loop_control:
    label: "{{ item.0.instance_name }} source={{ item.1 }}"
  register: runtime_ssh_timeout_domifaddr_by_source
  changed_when: false
  failed_when: false
  when:
    - (runtime_ssh_timeout_targets | default([])) | length > 0

- name: Collect domifaddr diagnostics for TCP SSH port timeout instances
  ansible.builtin.command:
    cmd: virsh domifaddr "{{ item }}"
  loop: "{{ runtime_ssh_timeout_instances | default([]) }}"
  loop_control:
    label: "{{ item }}"
  register: runtime_ssh_timeout_domifaddr
  changed_when: false
  failed_when: false
  when:
    - (runtime_ssh_timeout_instances | default([])) | length > 0

- name: Fail with actionable diagnostics when TCP SSH port wait fails
  ansible.builtin.fail:
    msg: >-
      TCP port {{ (instance_runtime_targets | first).ssh_port | default(22) }} wait timed out for instance(s): {{
      runtime_ssh_timeout_instances | join(', ')
      }}.
      Verify guest network and cloud-init boot progress.
      Note: this project uses libvirt URI '{{ kvm_libvirt_connection_uri | default('qemu:///system') }}'.
      If plain 'virsh' shows "domain not found", check using the same URI:
      virsh -c {{ kvm_libvirt_connection_uri | default('qemu:///system') }} domiflist <instance>
      virsh -c {{ kvm_libvirt_connection_uri | default('qemu:///system') }} domifaddr <instance>
      Suggested recovery:
      1) make cleanup-force-disks
      2) make provision
      debian12_hint={{ runtime_ssh_timeout_debian12_instances | default([]) }}
      ping_targets={{ runtime_ssh_timeout_targets | default([]) | map(attribute='instance_name') | list }}
      ping_rc={{ runtime_ssh_timeout_ping.results | default([]) | map(attribute='rc') | list }}
      domiflist={{ runtime_ssh_timeout_domiflist.results | default([]) | map(attribute='stdout') | join(' || ') }}
      domifaddr_sources={{ runtime_ssh_timeout_domifaddr_by_source.results | default([]) | map(attribute='stdout') | join(' || ') }}
      domifaddr={{ runtime_ssh_timeout_domifaddr.results | default([]) | map(attribute='stdout') | join(' || ') }}
  when:
    - (runtime_ssh_timeout_instances | default([])) | length > 0

- name: Build runtime TCP-ready instance list
  ansible.builtin.set_fact:
    runtime_tcp_ready_instances: >-
      {{
        ssh_wait_results.results
        | default([])
        | selectattr('state', 'defined')
        | selectattr('state', 'equalto', 'started')
        | map(attribute='item.instance_name')
        | list
      }}
  when:
    - kvm_run_mutation_phases | bool
    - kvm_wait_for_instance_ssh | default(true) | bool

- name: Build pre-snapshot TCP wait target list
  ansible.builtin.set_fact:
    instances_requiring_pre_snapshot_port_check: >-
      {{
        (
          instances_to_create | default([])
          if not (
            (kvm_skip_pre_snapshot_port_recheck | default(true) | bool)
            and (kvm_wait_for_instance_ssh | default(true) | bool)
          )
          else (
            (instances_to_create | default([]))
            | rejectattr('instance_name', 'in', runtime_tcp_ready_instances | default([]))
            | list
          )
        )
      }}
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - (instances_to_create | default([])) | length > 0

- name: Wait for TCP SSH port on newly created instances before snapshot
  ansible.builtin.wait_for:
    host: "{{ item.instance_ipv4_address }}"
    port: "{{ item.ssh_port | int }}"
    delay: 0
    timeout: >-
      {{
        (
          kvm_debian12_network_boot_wait_timeout_seconds
          if (item.image_profile_id | default('')) == 'debian-12'
          else (kvm_wait_for_cloud_init_timeout_seconds | default(600))
        ) | int
      }}
    state: started
  loop: "{{ instances_requiring_pre_snapshot_port_check | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  register: cloud_init_port_wait_results
  failed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_requiring_pre_snapshot_port_check | default([])) | length > 0

- name: Build list of TCP SSH port timeout failures before snapshot
  ansible.builtin.set_fact:
    cloud_init_port_timeout_instances: []
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_requiring_pre_snapshot_port_check | default([])) | length > 0

- name: Collect TCP SSH port timeout failures before snapshot
  ansible.builtin.set_fact:
    cloud_init_port_timeout_instances: "{{ (cloud_init_port_timeout_instances + [item.item.instance_name]) | unique }}"
  loop: "{{ cloud_init_port_wait_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_requiring_pre_snapshot_port_check | default([])) | length > 0
    - >-
      (
        item.failed | default(false) | bool
      )
      or
      (
        (
          item.state is defined
        )
        and
        (
          (item.state | default('')) != 'started'
        )
      )
      or
      (
        item.msg is defined
        and
        (
          (item.msg | default('')) is search('Timeout when waiting')
        )
      )

- name: Fail when TCP SSH port is not reachable before snapshot
  ansible.builtin.fail:
    msg: >-
      TCP port {{ (instances_to_create | first).ssh_port | default(22) }} was not reachable
      for instance(s): {{ cloud_init_port_timeout_instances | join(', ') }} before snapshot.
      Check guest boot/network and increase kvm_wait_for_cloud_init_timeout_seconds when needed.
  when:
    - (cloud_init_port_timeout_instances | default([])) | length > 0

- name: Check sshpass availability for optional password-based cloud-init wait
  ansible.builtin.command:
    cmd: bash -lc "command -v sshpass"
  register: cloud_init_wait_sshpass_check
  changed_when: false
  failed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_to_create | default([])) | length > 0
    - (cloud_init_port_timeout_instances | default([])) | length == 0

- name: Confirm cloud-init boot-finished marker before snapshot
  ansible.builtin.shell: |
    set -euo pipefail
    remote_cmd='cloud-init status --wait >/dev/null 2>&1 || while [ ! -f /var/lib/cloud/instance/boot-finished ]; do sleep 2; done'
    if {{
      (
        (item.cloud_init_ssh_password_auth | default(false) | bool)
        and (item.cloud_init_plain_password | default('') | length > 0)
        and ((cloud_init_wait_sshpass_check.rc | default(1)) == 0)
      ) | ternary('true', 'false')
    }}; then
      timeout "{{ kvm_wait_for_cloud_init_timeout_seconds | default(600) | int }}" \
        sshpass -p {{ item.cloud_init_plain_password | quote }} \
        ssh -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 \
          -o PreferredAuthentications=password -o PubkeyAuthentication=no \
          -p "{{ item.ssh_port | int }}" \
          "{{ item.cloud_init_user }}@{{ item.instance_ipv4_address }}" \
          "sh -lc \"$remote_cmd\""
    else
      timeout "{{ kvm_wait_for_cloud_init_timeout_seconds | default(600) | int }}" \
        ssh -o BatchMode=yes -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 \
          -p "{{ item.ssh_port | int }}" \
          "{{ item.cloud_init_user }}@{{ item.instance_ipv4_address }}" \
          "sh -lc \"$remote_cmd\""
    fi
  args:
    executable: /bin/bash
  loop: "{{ instances_to_create | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  register: cloud_init_marker_wait_results
  changed_when: false
  failed_when: false
  no_log: true
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_to_create | default([])) | length > 0
    - (cloud_init_port_timeout_instances | default([])) | length == 0

- name: Build list of cloud-init readiness failures before snapshot
  ansible.builtin.set_fact:
    cloud_init_marker_timeout_instances: []
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_to_create | default([])) | length > 0
    - (cloud_init_port_timeout_instances | default([])) | length == 0

- name: Collect cloud-init readiness failures before snapshot
  ansible.builtin.set_fact:
    cloud_init_marker_timeout_instances: "{{ (cloud_init_marker_timeout_instances + [item.item.instance_name]) | unique }}"
  loop: "{{ cloud_init_marker_wait_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_wait_for_cloud_init_before_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_to_create | default([])) | length > 0
    - (cloud_init_port_timeout_instances | default([])) | length == 0
    - (item.rc | default(0) | int) != 0

- name: Fail when cloud-init readiness check does not complete before snapshot
  ansible.builtin.fail:
    msg: >-
      Cloud-init readiness check did not complete for instance(s): {{
      cloud_init_marker_timeout_instances | join(', ')
      }} before snapshot.
      This gate waits on cloud-init completion (not a fixed sleep) and can run as key-based SSH or
      password-based SSH when sshpass is available and cloud_init_plain_password is set.
      Increase kvm_wait_for_cloud_init_timeout_seconds for slow mirrors, or disable this gate with
      kvm_wait_for_cloud_init_before_snapshot=false if you intentionally do not provide guest SSH auth.
  when:
    - (cloud_init_marker_timeout_instances | default([])) | length > 0

- name: Shut down newly created instances for snapshot
  ansible.builtin.command:
    cmd: virsh shutdown "{{ item.instance_name }}"
  loop: "{{ instances_to_create | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  async: 90
  poll: 0
  register: snapshot_shutdown_jobs
  changed_when: true
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - (instances_to_create | default([])) | length > 0

- name: Wait for snapshot shutdown commands
  ansible.builtin.async_status:
    jid: "{{ item.ansible_job_id }}"
  loop: "{{ snapshot_shutdown_jobs.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  register: snapshot_shutdown_status
  until: (snapshot_shutdown_status.finished | default(false)) | bool
  retries: 18
  delay: 5
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - item.ansible_job_id is defined

- name: Wait for newly created instances to be shut off
  ansible.builtin.command:
    cmd: virsh domstate "{{ item.instance_name }}"
  loop: "{{ instances_to_create | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  register: snapshot_vm_state
  until: snapshot_vm_state.stdout == 'shut off'
  retries: 40
  delay: 3
  changed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - (instances_to_create | default([])) | length > 0

- name: Create snapshots for newly created instances
  ansible.builtin.command:
    cmd: >-
      virsh snapshot-create-as "{{ item.instance_name }}"
      --name "{{ kvm_snapshot_name }}"
      --description "{{ kvm_snapshot_description }}"
  loop: "{{ instances_to_create | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  async: 180
  poll: 0
  register: snapshot_jobs
  changed_when: true
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - (instances_to_create | default([])) | length > 0

- name: Wait for snapshot creation operations
  ansible.builtin.async_status:
    jid: "{{ item.ansible_job_id }}"
  loop: "{{ snapshot_jobs.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  register: snapshot_status
  until: (snapshot_status.finished | default(false)) | bool
  retries: 36
  delay: 5
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - item.ansible_job_id is defined

- name: Start instances after snapshot
  ansible.builtin.command:
    cmd: virsh start "{{ item.instance_name }}"
  loop: "{{ instances_to_create | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  async: 90
  poll: 0
  register: post_snapshot_start_jobs
  changed_when: true
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_start_instances_after_snapshot | default(true) | bool
    - (instances_to_create | default([])) | length > 0

- name: Wait for post-snapshot start operations
  ansible.builtin.async_status:
    jid: "{{ item.ansible_job_id }}"
  loop: "{{ post_snapshot_start_jobs.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  register: post_snapshot_start_status
  until: (post_snapshot_start_status.finished | default(false)) | bool
  retries: 18
  delay: 5
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_start_instances_after_snapshot | default(true) | bool
    - item.ansible_job_id is defined

- name: Confirm TCP SSH port after snapshot restart
  ansible.builtin.wait_for:
    host: "{{ item.instance_ipv4_address }}"
    port: "{{ item.ssh_port | int }}"
    delay: 5
    timeout: >-
      {{
        (
          kvm_debian12_network_boot_wait_timeout_seconds
          if (item.image_profile_id | default('')) == 'debian-12'
          else (kvm_wait_for_ssh_timeout_seconds | default(180))
        ) | int
      }}
    state: started
  loop: "{{ instances_to_create | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }} ({{ item.instance_ipv4_address }}:{{ item.ssh_port | int }})"
  register: post_snapshot_ssh_results
  changed_when: false
  failed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_start_instances_after_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - (instances_to_create | default([])) | length > 0

- name: Build list of post-snapshot TCP SSH port timeout failures
  ansible.builtin.set_fact:
    post_snapshot_ssh_timeout_instances: []
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_start_instances_after_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool

- name: Collect post-snapshot TCP SSH port timeout failures
  ansible.builtin.set_fact:
    post_snapshot_ssh_timeout_instances: "{{ (post_snapshot_ssh_timeout_instances + [item.item.instance_name]) | unique }}"
  loop: "{{ post_snapshot_ssh_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - kvm_snapshot_enabled | default(true) | bool
    - kvm_start_instances_after_snapshot | default(true) | bool
    - kvm_wait_for_instance_ssh | default(true) | bool
    - >-
      (
        item.failed | default(false) | bool
      )
      or
      (
        item.state is defined
        and
        (
          (item.state | default('')) != 'started'
        )
      )
      or
      (
        item.msg is defined
        and
        (
          (item.msg | default('')) is search('Timeout when waiting')
        )
      )

- name: Fail when post-snapshot TCP SSH port is not reachable
  ansible.builtin.fail:
    msg: >-
      Post-snapshot TCP port {{ (instances_to_create | first).ssh_port | default(22) }} wait timed out
      for instance(s): {{ post_snapshot_ssh_timeout_instances | join(', ') }}.
      Check guest boot/network before continuing.
  when:
    - (post_snapshot_ssh_timeout_instances | default([])) | length > 0

- name: Runtime stage summary
  ansible.builtin.debug:
    msg: >-
      Runtime stage complete: started={{ (instances_to_start | default([])) | length }}
      requested_targets={{ instance_runtime_targets | length }}.
