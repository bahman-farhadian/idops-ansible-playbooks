---
# =========================================================================
# SHARED: resolve official checksums from Debian manifests
# =========================================================================
- name: Validate checksum algorithm values for required images
  ansible.builtin.assert:
    that:
      - item.image_checksum_algorithm in ['sha256', 'sha512']
      - item.image_checksum_manifest_url is defined
      - item.image_checksum_manifest_url | length > 0
    fail_msg: >-
      Invalid checksum metadata for profile {{ item.profile_id }}.
      image_checksum_algorithm must be sha256 or sha512,
      and image_checksum_manifest_url must be set.
  loop: "{{ required_cloud_images }}"
  loop_control:
    label: "{{ item.profile_id }}"

- name: Normalize image cache path for metadata resolution
  ansible.builtin.set_fact:
    normalized_image_cache_path: "{{ kvm_image_cache_path | regex_replace('/+$', '') }}"

- name: Check canonical alias image presence by profile
  ansible.builtin.stat:
    path: "{{ normalized_image_cache_path }}/{{ item.image_filename }}"
    get_checksum: false
  loop: "{{ required_cloud_images }}"
  loop_control:
    label: "{{ item.profile_id }}"
  register: image_alias_presence_stats
  changed_when: false

- name: Build canonical alias presence map by profile
  ansible.builtin.set_fact:
    image_alias_exists_by_profile: >-
      {{
        (image_alias_exists_by_profile | default({}))
        | combine({item.item.profile_id: (item.stat.exists | default(false))})
      }}
  loop: "{{ image_alias_presence_stats.results | default([]) }}"
  loop_control:
    label: "{{ item.item.profile_id }}"

- name: Initialize list of profiles that require manifest fetch
  ansible.builtin.set_fact:
    manifest_fetch_required_profiles: []

- name: Select profiles that require manifest fetch in current run
  ansible.builtin.set_fact:
    manifest_fetch_required_profiles: "{{ (manifest_fetch_required_profiles + [item.profile_id]) | unique }}"
  loop: "{{ required_cloud_images }}"
  loop_control:
    label: "{{ item.profile_id }}"
  when:
    - (kvm_force_manifest_refresh | default(false) | bool)
      or ((kvm_image_manifest_refresh_policy | default('on-demand')) == 'always')
      or (kvm_run_stage_image_cache | bool)
      or not (image_alias_exists_by_profile[item.profile_id] | default(false))

- name: Build list of profiles using cached metadata fallback (manifest skipped)
  ansible.builtin.set_fact:
    manifest_fetch_skipped_profiles: >-
      {{
        (
          required_cloud_images | map(attribute='profile_id') | list
        )
        | difference(manifest_fetch_required_profiles | default([]))
      }}

- name: Explain manifest fetch skip decisions for on-demand policy
  ansible.builtin.debug:
    msg: >-
      Skipping manifest fetch for cached profile(s): {{
      manifest_fetch_skipped_profiles | join(', ')
      }}.
      Provision flow will use canonical alias paths.
  when: (manifest_fetch_skipped_profiles | default([])) | length > 0

- name: Fetch official checksum manifests for required profiles
  ansible.builtin.uri:
    url: "{{ item.image_checksum_manifest_url }}"
    return_content: true
    method: GET
  loop: >-
    {{
      required_cloud_images
      | selectattr('profile_id', 'in', manifest_fetch_required_profiles | default([]))
      | list
    }}
  loop_control:
    label: "{{ item.profile_id }}"
  register: checksum_manifest_fetch_results
  changed_when: false
  when: (manifest_fetch_required_profiles | default([])) | length > 0

- name: Initialize resolved cloud image metadata list
  ansible.builtin.set_fact:
    required_cloud_images_resolved: []

- name: Resolve official checksum and versioned cache path per profile
  ansible.builtin.set_fact:
    required_cloud_images_resolved: >-
      {{
        (required_cloud_images_resolved | default([]))
        + [
          item.item
          | combine(
              {
                'official_checksum': official_checksum,
                'checksum_expected_length': checksum_expected_length,
                'cached_image_versioned_filename': versioned_filename,
                'cached_image_path': (normalized_image_cache_path ~ '/' ~ versioned_filename),
                'cached_image_alias_path': (normalized_image_cache_path ~ '/' ~ item.item.image_filename)
              },
              recursive=True
            )
        ]
      }}
  vars:
    normalized_image_cache_path: >-
      {{ kvm_image_cache_path | regex_replace('/+$', '') }}
    checksum_lines: >-
      {{
        item.content.splitlines()
        | select('search', '\\*?' ~ (item.item.image_filename | regex_escape) ~ '$')
        | list
      }}
    checksum_line: "{{ checksum_lines | first | default('') }}"
    official_checksum: "{{ (checksum_line.split() | first | default('')) | lower }}"
    checksum_expected_length: "{{ 64 if item.item.image_checksum_algorithm == 'sha256' else 128 }}"
    filename_base: "{{ item.item.image_filename | regex_replace('\\.[^./]+$', '') }}"
    filename_ext: "{{ (item.item.image_filename | regex_search('\\.[^./]+$')) | default('') }}"
    versioned_filename: >-
      {{
        filename_base
        ~ '-'
        ~ (
          (official_checksum[0:16])
          if (official_checksum | length > 0)
          else 'unresolved'
        )
        ~ filename_ext
      }}
  loop: "{{ checksum_manifest_fetch_results.results | default([]) }}"
  loop_control:
    label: "{{ item.item.profile_id }}"

- name: Add cached-alias fallback metadata for manifest-skipped profiles
  ansible.builtin.set_fact:
    required_cloud_images_resolved: >-
      {{
        (required_cloud_images_resolved | default([]))
        + [
          item
          | combine(
              {
                'official_checksum': '',
                'checksum_expected_length': (64 if item.image_checksum_algorithm == 'sha256' else 128),
                'cached_image_versioned_filename': item.image_filename,
                'cached_image_path': (normalized_image_cache_path ~ '/' ~ item.image_filename),
                'cached_image_alias_path': (normalized_image_cache_path ~ '/' ~ item.image_filename)
              },
              recursive=True
            )
        ]
      }}
  loop: >-
    {{
      required_cloud_images
      | selectattr('profile_id', 'in', manifest_fetch_skipped_profiles | default([]))
      | list
    }}
  loop_control:
    label: "{{ item.profile_id }}"

- name: Fail when official checksum cannot be resolved from manifest
  ansible.builtin.fail:
    msg: >-
      Could not resolve checksum for profile {{ item.profile_id }} ({{ item.image_filename }})
      from manifest {{ item.image_checksum_manifest_url }}.
  loop: "{{ required_cloud_images_resolved | default([]) }}"
  loop_control:
    label: "{{ item.profile_id }}"
  when:
    - item.profile_id in (manifest_fetch_required_profiles | default([]))
    - (item.official_checksum | default('') | length) == 0

- name: Fail when checksum length does not match checksum algorithm
  ansible.builtin.fail:
    msg: >-
      Resolved checksum length mismatch for profile {{ item.profile_id }}.
      Algorithm={{ item.image_checksum_algorithm }} expected_len={{ item.checksum_expected_length }}
      actual_len={{ item.official_checksum | length }}.
  loop: "{{ required_cloud_images_resolved | default([]) }}"
  loop_control:
    label: "{{ item.profile_id }}"
  when:
    - item.profile_id in (manifest_fetch_required_profiles | default([]))
    - (item.official_checksum | length) != (item.checksum_expected_length | int)

- name: Build resolved cache path map by image profile
  ansible.builtin.set_fact:
    resolved_cloud_image_path_by_profile: >-
      {{
        (resolved_cloud_image_path_by_profile | default({}))
        | combine({item.profile_id: item.cached_image_path})
      }}
  loop: "{{ required_cloud_images_resolved | default([]) }}"
  loop_control:
    label: "{{ item.profile_id }}"
