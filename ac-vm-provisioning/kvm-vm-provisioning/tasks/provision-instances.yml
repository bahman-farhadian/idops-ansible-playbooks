---
# =========================================================================
# STAGE: provision (create domains/disks from cached cloud images)
# =========================================================================
- name: Explain provision stage skip in check mode
  ansible.builtin.debug:
    msg: >-
      Provision stage is skipped because mutation phases are disabled in check mode.
      Run make provision to create disks, seed images, and domains.
  when: not (kvm_run_mutation_phases | bool)

- name: No new instances to provision
  ansible.builtin.debug:
    msg: "All requested instances already exist; no new instance provisioning required."
  when: instances_to_create | length == 0

- name: Stop provision stage when there are no instances to create
  ansible.builtin.meta: end_host
  when:
    - kvm_selected_stage == 'provision'
    - instances_to_create | length == 0

- name: Build materialized instance path model
  ansible.builtin.set_fact:
    instances_to_create_materialized: []
  when: instances_to_create | length > 0

- name: Build normalized path variables for materialized instances
  ansible.builtin.set_fact:
    normalized_image_cache_path: "{{ kvm_image_cache_path | regex_replace('/+$', '') }}"
    normalized_instance_disk_pool_path: "{{ kvm_instance_disk_pool_path | regex_replace('/+$', '') }}"
    normalized_cloud_init_workspace_path: "{{ kvm_cloud_init_workspace_path | regex_replace('/+$', '') }}"
  when: instances_to_create | length > 0

- name: Normalize provision-stage parallel worker count
  ansible.builtin.set_fact:
    kvm_effective_parallel_instance_workers: "{{ [1, (kvm_parallel_instance_workers | default(4) | int)] | max }}"
  when: instances_to_create | length > 0

- name: Build materialized path entries per instance
  ansible.builtin.set_fact:
    instances_to_create_materialized: >-
      {{
        (instances_to_create_materialized | default([]))
        + [
          item
          | combine(
              {
                'base_image_path': (
                  resolved_cloud_image_path_by_profile[item.image_profile_id]
                  | default(normalized_image_cache_path ~ '/' ~ item.image_filename)
                ),
                'instance_disk_path': (normalized_instance_disk_pool_path ~ '/' ~ item.instance_name ~ '.' ~ item.instance_disk_extension),
                'seed_disk_path': (normalized_instance_disk_pool_path ~ '/' ~ item.instance_name ~ '-seed.img'),
                'cloud_init_user_data_path': (normalized_cloud_init_workspace_path ~ '/' ~ item.instance_name ~ '-user-data.yaml'),
                'cloud_init_meta_data_path': (normalized_cloud_init_workspace_path ~ '/' ~ item.instance_name ~ '-meta-data.yaml'),
                'cloud_init_network_path': (normalized_cloud_init_workspace_path ~ '/' ~ item.instance_name ~ '-network-config.yaml'),
                'guest_network_interface_candidates': (
                  (
                    [item.guest_network_interface]
                    + (
                      kvm_guest_network_interface_fallbacks
                      | default(['ens3', 'enp1s0', 'eth0'])
                    )
                  )
                  | map('trim')
                  | reject('equalto', '')
                  | unique
                  | list
                ),
                'instance_mac_address': (
                  item.instance_mac_address
                  if (item.instance_mac_address is defined and (item.instance_mac_address | length > 0))
                  else (
                    '52:54:00:'
                    ~ (item.instance_name | hash('sha1'))[0:2]
                    ~ ':'
                    ~ (item.instance_name | hash('sha1'))[2:4]
                    ~ ':'
                    ~ (item.instance_name | hash('sha1'))[4:6]
                  )
                )
              },
              recursive=True
            )
        ]
      }}
  loop: "{{ instances_to_create }}"
  loop_control:
    label: "{{ item.instance_name }}"
  when: instances_to_create | length > 0

- name: Validate required command availability for provision stage
  ansible.builtin.command:
    cmd: "which {{ item }}"
  loop:
    - virsh
    - qemu-img
    - cloud-localds
    - virt-install
  loop_control:
    label: "{{ item }}"
  register: provision_command_checks
  changed_when: false
  failed_when: false
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - not (kvm_preflight_commands_validated | default(false) | bool)

- name: Fail when required provision commands are missing
  ansible.builtin.fail:
    msg: >-
      Missing required commands for provision stage: {{
      provision_command_checks.results
      | rejectattr('rc', 'eq', 0)
      | map(attribute='item')
      | join(', ')
      }}.
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - not (kvm_preflight_commands_validated | default(false) | bool)
    - >-
      (
        provision_command_checks.results
        | rejectattr('rc', 'eq', 0)
        | list
        | length
      ) > 0

- name: Initialize required UEFI firmware file list
  ansible.builtin.set_fact:
    required_uefi_firmware_files: []
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool

- name: Build required UEFI firmware file list for instances to create
  ansible.builtin.set_fact:
    required_uefi_firmware_files: >-
      {{
        (
          required_uefi_firmware_files
          + [
              '/usr/share/OVMF/OVMF_CODE_4M.ms.fd',
              '/usr/share/OVMF/OVMF_VARS_4M.ms.fd'
            ]
        )
        | unique
      }}
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - (item.firmware_boot_mode | default('uefi') | lower) == 'uefi'

- name: Validate required UEFI firmware files exist
  ansible.builtin.stat:
    path: "{{ item }}"
  loop: "{{ required_uefi_firmware_files | default([]) }}"
  loop_control:
    label: "{{ item }}"
  register: uefi_firmware_stats
  changed_when: false
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - (required_uefi_firmware_files | default([])) | length > 0

- name: Fail when required UEFI firmware files are missing
  ansible.builtin.fail:
    msg: >-
      Required UEFI firmware file is missing: {{ item.item }}.
      Install/verify OVMF secure-boot firmware on the hypervisor.
  loop: "{{ uefi_firmware_stats.results | default([]) }}"
  loop_control:
    label: "{{ item.item }}"
  when:
    - not (item.stat.exists | default(false))

- name: Validate base cloud images exist for instances to create
  ansible.builtin.stat:
    path: "{{ item.base_image_path }}"
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  register: base_image_stats
  changed_when: false

- name: Fail when base cloud images are missing
  ansible.builtin.fail:
    msg: >-
      Base cloud image is missing for instance {{ item.item.instance_name }}:
      {{ item.item.base_image_path }}.
      Run make image-cache first, or fix kvm_cloud_image_catalog values.
  loop: "{{ base_image_stats.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  when: not (item.stat.exists | default(false))

- name: Ensure cloud-init workspace path exists
  ansible.builtin.file:
    path: "{{ kvm_cloud_init_workspace_path }}"
    state: directory
    mode: "0700"
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool

- name: Validate runtime user access to instance disk pool path
  ansible.builtin.command:
    cmd: "stat {{ kvm_instance_disk_pool_path }}"
  become: true
  become_user: "{{ kvm_libvirt_runtime_user | default('libvirt-qemu') }}"
  register: runtime_pool_access_check
  changed_when: false
  failed_when: false
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool

- name: Build unique base image paths for runtime access checks
  ansible.builtin.set_fact:
    provision_required_base_images: >-
      {{
        instances_to_create_materialized
        | default([])
        | map(attribute='base_image_path')
        | unique
        | list
      }}
  when:
    - instances_to_create | length > 0
    - kvm_validate_runtime_pool_access | default(true) | bool

- name: Validate runtime user access to base cloud images
  ansible.builtin.command:
    cmd: "stat {{ item }}"
  loop: "{{ provision_required_base_images | default([]) }}"
  loop_control:
    label: "{{ item }}"
  become: true
  become_user: "{{ kvm_libvirt_runtime_user | default('libvirt-qemu') }}"
  register: runtime_base_image_access_check
  changed_when: false
  failed_when: false
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool

- name: Build runtime access failure model for provision stage
  ansible.builtin.set_fact:
    runtime_pool_access_failed: "{{ (runtime_pool_access_check.rc | default(0) | int) != 0 }}"
    runtime_base_access_failures: >-
      {{
        runtime_base_image_access_check.results
        | default([])
        | selectattr('rc', 'defined')
        | rejectattr('rc', 'eq', 0)
        | map(attribute='item')
        | list
      }}
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool

- name: Build runtime ACL auto-fix target list for provision stage
  ansible.builtin.set_fact:
    runtime_acl_fix_targets: >-
      {{
        (
          ([kvm_instance_disk_pool_path] if (runtime_pool_access_failed | default(false)) else [])
          + (runtime_base_access_failures | default([]))
        )
        | unique
      }}
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool
    - kvm_auto_fix_runtime_pool_access | default(true) | bool

- name: Auto-fix runtime ACLs for pool and base images
  ansible.builtin.shell: |
    set -euo pipefail
    runtime_user={{ (kvm_libvirt_runtime_user | default('libvirt-qemu')) | quote }}
    target={{ item | quote }}
    if [ -d "$target" ]; then
      parent="$target"
      target_is_dir=1
    else
      parent="$(dirname "$target")"
      target_is_dir=0
    fi

    current="$parent"
    while [ "$current" != "/" ] && [ -n "$current" ]; do
      setfacl -m "u:${runtime_user}:x" "$current"
      current="$(dirname "$current")"
    done

    if [ "$target_is_dir" -eq 1 ]; then
      setfacl -m "u:${runtime_user}:rwx" "$target"
      setfacl -m "d:u:${runtime_user}:rwx" "$target"
    else
      setfacl -m "u:${runtime_user}:r" "$target"
    fi
  args:
    executable: /bin/bash
  loop: "{{ runtime_acl_fix_targets | default([]) }}"
  loop_control:
    label: "{{ item }}"
  become: true
  register: runtime_acl_fix_results
  changed_when: true
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool
    - kvm_auto_fix_runtime_pool_access | default(true) | bool
    - (runtime_acl_fix_targets | default([])) | length > 0

- name: Re-check runtime user access to instance disk pool path
  ansible.builtin.command:
    cmd: "stat {{ kvm_instance_disk_pool_path }}"
  become: true
  become_user: "{{ kvm_libvirt_runtime_user | default('libvirt-qemu') }}"
  register: runtime_pool_access_check_after_fix
  changed_when: false
  failed_when: false
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool

- name: Re-check runtime user access to base cloud images
  ansible.builtin.command:
    cmd: "stat {{ item }}"
  loop: "{{ provision_required_base_images | default([]) }}"
  loop_control:
    label: "{{ item }}"
  become: true
  become_user: "{{ kvm_libvirt_runtime_user | default('libvirt-qemu') }}"
  register: runtime_base_image_access_check_after_fix
  changed_when: false
  failed_when: false
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool

- name: Fail when runtime user cannot access instance disk pool path
  ansible.builtin.fail:
    msg: >-
      Libvirt runtime user '{{ kvm_libvirt_runtime_user | default('libvirt-qemu') }}'
      cannot access kvm_instance_disk_pool_path: {{ kvm_instance_disk_pool_path }}.
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool
    - (runtime_pool_access_check_after_fix.rc | default(runtime_pool_access_check.rc | default(0)) | int) != 0

- name: Fail when runtime user cannot access base cloud image files
  ansible.builtin.fail:
    msg: >-
      Libvirt runtime user '{{ kvm_libvirt_runtime_user | default('libvirt-qemu') }}'
      cannot access base cloud image file(s): {{
      (
        runtime_base_image_access_check_after_fix.results
        | default(runtime_base_image_access_check.results | default([]))
        | selectattr('rc', 'defined')
        | rejectattr('rc', 'eq', 0)
        | map(attribute='item')
        | list
      ) | join(', ')
      }}.
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool
    - kvm_validate_runtime_pool_access | default(true) | bool
    - >-
      (
        runtime_base_image_access_check_after_fix.results
        | default(runtime_base_image_access_check.results | default([]))
        | selectattr('rc', 'defined')
        | rejectattr('rc', 'eq', 0)
        | list
        | length
      ) > 0

- name: Check target instance disk files
  ansible.builtin.stat:
    path: "{{ item.instance_disk_path }}"
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  register: instance_disk_stats
  changed_when: false

- name: Fail when target instance disk files already exist and reuse is disabled
  ansible.builtin.fail:
    msg: >-
      Disk file already exists for instance {{ item.item.instance_name }}:
      {{ item.item.instance_disk_path }}.
      Set kvm_allow_reuse_existing_instance_disks=true to reuse existing files,
      or run: make cleanup-force-disks
      (cleanup is exact-name scoped to declared instances only).
  loop: "{{ instance_disk_stats.results | default([]) }}"
  loop_control:
    label: "{{ item.item.instance_name }}"
  when:
    - item.stat.exists | default(false)
    - not (kvm_allow_reuse_existing_instance_disks | default(false) | bool)

- name: Build list of instances requiring fresh disk creation
  ansible.builtin.set_fact:
    instances_requiring_disk_create: >-
      {{
        instances_to_create_materialized
        | zip(instance_disk_stats.results)
        | rejectattr('1.stat.exists', 'equalto', true)
        | map(attribute='0')
        | list
      }}
  when: instances_to_create | length > 0

- name: Remove stale seed iso files before regeneration
  ansible.builtin.file:
    path: "{{ item.seed_disk_path }}"
    state: absent
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  when:
    - instances_to_create | length > 0
    - kvm_run_mutation_phases | bool

- name: Build root-disk creation batches
  ansible.builtin.set_fact:
    root_disk_create_batches: >-
      {{
        (
          instances_requiring_disk_create
          | default([])
          | batch(kvm_effective_parallel_instance_workers | int)
          | map('list')
          | list
        )
      }}
  when:
    - kvm_run_mutation_phases | bool
    - (instances_requiring_disk_create | default([])) | length > 0

- name: Create and resize root disks in parallel batches
  ansible.builtin.include_tasks: tasks/provision-instances-batch-root-disks.yml
  loop: "{{ root_disk_create_batches | default([]) }}"
  loop_control:
    label: >-
      {{
        kvm_instance_batch | map(attribute='instance_name') | list | join(', ')
      }}
    loop_var: kvm_instance_batch
  when:
    - kvm_run_mutation_phases | bool
    - (instances_requiring_disk_create | default([])) | length > 0

- name: Check additional disk files for instances requiring creation
  ansible.builtin.stat:
    path: >-
      {{
        normalized_instance_disk_pool_path
        ~ '/'
        ~ item.0.instance_name
        ~ '-'
        ~ item.1.guest_device
        ~ '.'
        ~ (item.1.disk_extension | default(item.0.instance_disk_extension))
      }}
  loop: "{{ (instances_requiring_disk_create | default([])) | subelements('instance_extra_disks', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.instance_name }}:{{ item.1.guest_device }}"
  register: additional_disk_stats
  changed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - (instances_requiring_disk_create | default([])) | length > 0
    - item.0.instance_extra_disks_enabled | bool

- name: Fail when additional disk files already exist and reuse is disabled
  ansible.builtin.fail:
    msg: >-
      Additional disk file already exists for instance {{ item.item.0.instance_name }}
      on guest device {{ item.item.1.guest_device }}:
      {{
        normalized_instance_disk_pool_path
        ~ '/'
        ~ item.item.0.instance_name
        ~ '-'
        ~ item.item.1.guest_device
        ~ '.'
        ~ (item.item.1.disk_extension | default(item.item.0.instance_disk_extension))
      }}.
      Set kvm_allow_reuse_existing_instance_disks=true to reuse existing files,
      or run: make cleanup-force-disks.
  loop: "{{ additional_disk_stats.results | default([]) }}"
  loop_control:
    label: "{{ item.item.0.instance_name }}:{{ item.item.1.guest_device }}"
  when:
    - item.stat.exists | default(false)
    - not (kvm_allow_reuse_existing_instance_disks | default(false) | bool)

- name: Build list of additional disks requiring creation
  ansible.builtin.set_fact:
    additional_disks_requiring_create: >-
      {{
        additional_disk_stats.results
        | default([])
        | rejectattr('stat.exists', 'equalto', true)
        | map(attribute='item')
        | list
      }}
  when:
    - kvm_run_mutation_phases | bool
    - (instances_requiring_disk_create | default([])) | length > 0

- name: Build additional-disk creation batches
  ansible.builtin.set_fact:
    additional_disk_create_batches: >-
      {{
        (
          additional_disks_requiring_create
          | default([])
          | batch(kvm_effective_parallel_instance_workers | int)
          | map('list')
          | list
        )
      }}
  when:
    - kvm_run_mutation_phases | bool
    - (additional_disks_requiring_create | default([])) | length > 0

- name: Create additional disks in parallel batches
  ansible.builtin.include_tasks: tasks/provision-instances-batch-extra-disk-create.yml
  loop: "{{ additional_disk_create_batches | default([]) }}"
  loop_control:
    label: >-
      {{
        kvm_extra_disk_batch
        | map('first')
        | map(attribute='instance_name')
        | list
        | join(', ')
      }}
    loop_var: kvm_extra_disk_batch
  when:
    - kvm_run_mutation_phases | bool
    - (additional_disks_requiring_create | default([])) | length > 0

- name: Generate cloud-init user-data files
  ansible.builtin.copy:
    dest: "{{ item.cloud_init_user_data_path }}"
    mode: "0600"
    content: |
      #cloud-config
      hostname: {{ item.instance_name }}
      fqdn: {{ item.instance_name }}
      manage_etc_hosts: {{ (item.cloud_init_manage_etc_hosts | bool) | ternary('true', 'false') }}
      timezone: {{ item.cloud_init_timezone }}
      locale: {{ item.cloud_init_locale }}
      package_update: {{ (item.cloud_init_package_update | bool) | ternary('true', 'false') }}
      package_upgrade: {{ (item.cloud_init_package_upgrade | bool) | ternary('true', 'false') }}
      package_reboot_if_required: {{ (item.cloud_init_package_reboot_if_required | bool) | ternary('true', 'false') }}
      ssh_pwauth: {{ (item.cloud_init_ssh_password_auth | bool) | ternary('true', 'false') }}
      disable_root: {{ (item.cloud_init_disable_root | bool) | ternary('true', 'false') }}
      users:
        - name: {{ item.cloud_init_user }}
          shell: /bin/bash
          groups: [sudo]
          sudo: {{ item.cloud_init_user_sudo_rule | to_json }}
          lock_passwd: {{ (item.cloud_init_plain_password | length == 0) | ternary('true', 'false') }}
      {% if (item.cloud_init_ssh_public_keys | default([])) | length > 0 %}
          ssh_authorized_keys:
      {% for pubkey in item.cloud_init_ssh_public_keys %}
            - {{ pubkey }}
      {% endfor %}
      {% endif %}
      {% if (item.cloud_init_plain_password | length > 0) or ((item.cloud_init_root_plain_password | default('')) | length > 0) %}
      chpasswd:
        expire: false
        users:
      {% if item.cloud_init_plain_password | length > 0 %}
          - name: {{ item.cloud_init_user }}
            password: {{ item.cloud_init_plain_password | to_json }}
            type: text
      {% endif %}
      {% if (item.cloud_init_root_plain_password | default('')) | length > 0 %}
          - name: root
            password: {{ item.cloud_init_root_plain_password | to_json }}
            type: text
      {% endif %}
      {% endif %}
      {% if (item.cloud_init_apt_config | default({})) | length > 0 %}
      apt:
      {{ item.cloud_init_apt_config | to_nice_yaml(indent=2) | indent(2, true) }}
      {% endif %}
      {% if (item.cloud_init_packages | default([])) | length > 0 %}
      packages:
      {% for package_name in item.cloud_init_packages %}
        - {{ package_name | to_json }}
      {% endfor %}
      {% endif %}
      {% set generated_write_files = [] %}
      {% if (item.cloud_init_tune_networkd_wait_online | default(true) | bool) and ((item.image_profile_id | default('')) == 'debian-12') %}
      {% set generated_write_files = generated_write_files + [
        {
          'path': '/etc/systemd/system/systemd-networkd-wait-online.service.d/10-idops-timeout.conf',
          'owner': 'root:root',
          'permissions': '0644',
          'content': (
            '[Service]\n'
            ~ 'ExecStart=\n'
            ~ 'ExecStart=/lib/systemd/systemd-networkd-wait-online --timeout='
            ~ (
              item.cloud_init_networkd_wait_online_timeout_seconds
              | default(30)
              | int
              | string
            )
            ~ '\n'
          )
        }
      ] %}
      {% endif %}
      {% set effective_write_files = (item.cloud_init_write_files | default([])) + generated_write_files %}
      {% if (effective_write_files | default([])) | length > 0 %}
      write_files:
      {{ effective_write_files | to_nice_yaml(indent=2) | indent(2, true) }}
      {% endif %}
      {% if (item.cloud_init_bootcmd | default([])) | length > 0 %}
      bootcmd:
      {% for boot_command in item.cloud_init_bootcmd %}
        - {{ boot_command | to_json }}
      {% endfor %}
      {% endif %}
      {% if (item.cloud_init_runcmd | default([])) | length > 0 %}
      runcmd:
      {% for run_command in item.cloud_init_runcmd %}
        - {{ run_command | to_json }}
      {% endfor %}
      {% endif %}
      {% if (item.instance_extra_disks_enabled | bool) and ((item.instance_extra_disks | default([])) | length > 0) %}
      disk_setup:
      {% for extra_disk in item.instance_extra_disks %}
        /dev/{{ extra_disk.guest_device }}:
          table_type: gpt
          layout: true
          overwrite: false
      {% endfor %}
      fs_setup:
      {% for extra_disk in item.instance_extra_disks %}
        - label: {{ (extra_disk.filesystem_label | default((item.instance_name ~ '-' ~ extra_disk.guest_device)[0:16])) | to_json }}
          filesystem: {{ extra_disk.filesystem | default('ext4') }}
          device: /dev/{{ extra_disk.guest_device }}1
          partition: auto
      {% endfor %}
      mounts:
      {% for extra_disk in item.instance_extra_disks %}
        - [
            "/dev/{{ extra_disk.guest_device }}1",
            "{{ extra_disk.mount_point }}",
            "{{ extra_disk.filesystem | default('ext4') }}",
            "{{ extra_disk.mount_options | default('defaults,nofail') }}",
            "0",
            "2"
          ]
      {% endfor %}
      {% endif %}
      final_message: {{ item.cloud_init_final_message | to_json }}
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Generate cloud-init meta-data files
  ansible.builtin.copy:
    dest: "{{ item.cloud_init_meta_data_path }}"
    mode: "0600"
    content: |
      instance-id: {{ item.instance_name }}
      local-hostname: {{ item.instance_name }}
      dsmode: local
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Generate cloud-init network-config files
  ansible.builtin.copy:
    dest: "{{ item.cloud_init_network_path }}"
    mode: "0600"
    content: |
      version: 2
      ethernets:
        idops0:
          match:
            macaddress: "{{ item.instance_mac_address | lower }}"
      {% if item.image_profile_id != 'debian-12' %}
          set-name: "{{ item.guest_network_interface }}"
      {% endif %}
          dhcp4: false
          dhcp6: false
          optional: true
          addresses:
            - {{ item.instance_ipv4_address }}/{{ item.guest_network_prefix }}
          routes:
            - to: default
              via: {{ item.guest_network_gateway }}
          nameservers:
            addresses: {{ ([item.guest_dns_servers] if item.guest_dns_servers is string else item.guest_dns_servers) | to_json }}
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Build instance provisioning batches
  ansible.builtin.set_fact:
    instance_provision_batches: >-
      {{
        (
          instances_to_create_materialized
          | default([])
          | batch(kvm_effective_parallel_instance_workers | int)
          | map('list')
          | list
        )
      }}
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Build cloud-init seeds and define instances in parallel batches
  ansible.builtin.include_tasks: tasks/provision-instances-batch-seed-define.yml
  loop: "{{ instance_provision_batches | default([]) }}"
  loop_control:
    label: >-
      {{
        kvm_instance_batch | map(attribute='instance_name') | list | join(', ')
      }}
    loop_var: kvm_instance_batch
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Verify newly defined instances exist
  ansible.builtin.command:
    cmd: virsh dominfo "{{ item.instance_name }}"
  loop: "{{ instances_to_create_materialized | default([]) }}"
  loop_control:
    label: "{{ item.instance_name }}"
  changed_when: false
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Build additional-disk attach list
  ansible.builtin.set_fact:
    additional_disks_to_attach: []
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0

- name: Collect additional disks to attach for enabled instances
  ansible.builtin.set_fact:
    additional_disks_to_attach: >-
      {{
        additional_disks_to_attach
        + [item]
      }}
  loop: "{{ (instances_to_create_materialized | default([])) | subelements('instance_extra_disks', skip_missing=True) }}"
  loop_control:
    label: "{{ item.0.instance_name }}:{{ item.1.guest_device }}"
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0
    - item.0.instance_extra_disks_enabled | bool

- name: Build additional-disk attach batches
  ansible.builtin.set_fact:
    additional_disk_attach_batches: >-
      {{
        (
          additional_disks_to_attach
          | default([])
          | batch(kvm_effective_parallel_instance_workers | int)
          | map('list')
          | list
        )
      }}
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0
    - (additional_disks_to_attach | default([])) | length > 0

- name: Attach additional disks in parallel batches
  ansible.builtin.include_tasks: tasks/provision-instances-batch-extra-disk-attach.yml
  loop: "{{ additional_disk_attach_batches | default([]) }}"
  loop_control:
    label: >-
      {{
        kvm_extra_disk_attach_batch
        | map('first')
        | map(attribute='instance_name')
        | list
        | join(', ')
      }}
    loop_var: kvm_extra_disk_attach_batch
  when:
    - kvm_run_mutation_phases | bool
    - instances_to_create | length > 0
    - (additional_disks_to_attach | default([])) | length > 0

- name: Remove cloud-init workspace artifacts when enabled
  ansible.builtin.file:
    path: "{{ kvm_cloud_init_workspace_path }}"
    state: absent
  when:
    - kvm_run_mutation_phases | bool
    - kvm_cleanup_workspace_path_after_run | default(true) | bool

- name: Provision stage summary
  ansible.builtin.debug:
    msg: >-
      Provision stage complete: created={{ instances_to_create | length }} instance(s).
      Disk pool={{ kvm_instance_disk_pool_path }}.
